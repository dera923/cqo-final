#!/usr/bin/env python3
"""
CQOçµ±åˆã‚¨ãƒ³ã‚¸ãƒ³ - Module Aã¨A-Gateã®é€£æºå®Ÿè¡Œ

NASAæ¨™æº–:
- ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å®Ÿè¡Œå¯èƒ½
- å®Œå…¨ãªãƒ­ã‚°è¨˜éŒ²
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

Usage:
    python -m src.core.engine --data-path data/sample.csv --output results/
"""

import sys
import json
import yaml
from pathlib import Path
from typing import Optional, Dict, Any
import numpy as np
import pandas as pd
import typer
from rich.console import Console
from rich.table import Table
from rich import print as rprint
from loguru import logger

# ç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¯¾ç­–
sys.path.append(str(Path(__file__).parent.parent.parent))

from src.modules.module_a import DoublyRobustEstimator, EstimationResult
from src.gate.agate import AGate, GateStatus

app = typer.Typer(help="CQO Engine - Causal Quantum Optimizer")
console = Console()


class CQOEngine:
    """çµ±åˆå®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³"""
    
    def __init__(self, config_path: Optional[str] = None):
        """
        Args:
            config_path: è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ï¼ˆYAMLï¼‰
        """
        # è¨­å®šèª­ã¿è¾¼ã¿
        if config_path and Path(config_path).exists():
            with open(config_path, 'r') as f:
                self.config = yaml.safe_load(f)
        else:
            # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
            self.config = {
                'module_a': {
                    'n_splits': 5,
                    'enable_orthogonal': True
                },
                'gate': {
                    'strict_mode': True,
                    'enable_omega': False
                }
            }
        
        # ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–
        self.estimator = DoublyRobustEstimator(
            n_splits=self.config['module_a']['n_splits'],
            enable_orthogonal=self.config['module_a']['enable_orthogonal']
        )
        
        self.gate = AGate(
            thresholds=self.config.get('gate', {}).get('thresholds'),
            strict_mode=self.config['gate']['strict_mode'],
            enable_omega=self.config['gate']['enable_omega']
        )
        
        logger.info("CQO Engine initialized")
    
    def run(self, X: np.ndarray, T: np.ndarray, Y: np.ndarray,
            verbose: bool = True) -> Dict[str, Any]:
        """
        å› æœæ¨è«–ã®å®Ÿè¡Œã¨Gateè©•ä¾¡
        
        Returns:
            çµæœè¾æ›¸ï¼ˆATEã€ä¿¡é ¼åŒºé–“ã€Gateåˆ¤å®šã€ãƒ¢ãƒ¼ãƒ‰ï¼‰
        """
        # Step 1: DRæ¨å®š
        if verbose:
            console.print("[bold cyan]Step 1: Running Doubly Robust Estimation...[/bold cyan]")
        
        estimation_result = self.estimator.fit(X, T, Y)
        
        # Step 2: Gateè©•ä¾¡
        if verbose:
            console.print("[bold cyan]Step 2: Evaluating with A-Gate...[/bold cyan]")
        
        gate_result = self.gate.evaluate(estimation_result)
        
        # Step 3: çµæœæ•´å½¢
        output = {
            'ate': estimation_result.ate,
            'ci_lower': estimation_result.ate_ci_lower,
            'ci_upper': estimation_result.ate_ci_upper,
            'mode': gate_result.mode,
            'gate_status': gate_result.status.value,
            'violations': [v.value for v in gate_result.violations],
            'recommendations': gate_result.recommendations,
            'diagnostics': estimation_result.diagnostics,
            'signature': gate_result.signature
        }
        
        # Step 4: çµæœè¡¨ç¤º
        if verbose:
            self._display_results(output, gate_result)
        
        return output
    
    def _display_results(self, output: Dict, gate_result):
        """çµæœã®è¦–è¦šçš„è¡¨ç¤º"""
        # ATEçµæœãƒ†ãƒ¼ãƒ–ãƒ«
        table = Table(title="Estimation Results", show_header=True)
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="magenta")
        
        table.add_row("ATE", f"{output['ate']:.4f}")
        table.add_row("95% CI", f"[{output['ci_lower']:.4f}, {output['ci_upper']:.4f}]")
        table.add_row("Mode", output['mode'])
        table.add_row("Gate Status", output['gate_status'])
        
        console.print(table)
        
        # Gateè©•ä¾¡è©³ç´°
        if gate_result.violations:
            console.print("\n[bold red]âš  Violations:[/bold red]")
            for violation in output['violations']:
                console.print(f"  â€¢ {violation}")
        
        if output['recommendations']:
            console.print("\n[bold yellow]ğŸ’¡ Recommendations:[/bold yellow]")
            for rec in output['recommendations']:
                console.print(f"  â€¢ {rec}")
        
        # ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆè©³ç´°
        console.print("\n[bold]Gate Checkpoints:[/bold]")
        for checkpoint in gate_result.checkpoints:
            symbol = "âœ…" if checkpoint.passed else "âŒ"
            console.print(f"  {symbol} {checkpoint}")


@app.command()
def estimate(
    data_path: str = typer.Option(..., help="Path to data CSV"),
    treatment_col: str = typer.Option("treatment", help="Treatment column name"),
    outcome_col: str = typer.Option("outcome", help="Outcome column name"),
    config: Optional[str] = typer.Option(None, help="Config YAML path"),
    output: Optional[str] = typer.Option(None, help="Output JSON path"),
    verbose: bool = typer.Option(True, help="Verbose output")
):
    """
    ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å› æœåŠ¹æœã‚’æ¨å®š
    
    Example:
        python -m src.core.engine estimate --data-path data/sample.csv
    """
    try:
        # ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
        console.print(f"[bold]Loading data from {data_path}...[/bold]")
        df = pd.read_csv(data_path)
        
        # ç‰¹å¾´é‡ã€å‡¦ç½®ã€ã‚¢ã‚¦ãƒˆã‚«ãƒ ã®åˆ†é›¢
        feature_cols = [col for col in df.columns 
                       if col not in [treatment_col, outcome_col]]
        
        X = df[feature_cols].values
        T = df[treatment_col].values
        Y = df[outcome_col].values
        
        console.print(f"Data shape: {X.shape[0]} samples, {X.shape[1]} features")
        
        # ã‚¨ãƒ³ã‚¸ãƒ³å®Ÿè¡Œ
        engine = CQOEngine(config)
        result = engine.run(X, T, Y, verbose=verbose)
        
        # çµæœä¿å­˜
        if output:
            with open(output, 'w') as f:
                json.dump(result, f, indent=2)
            console.print(f"\n[green]Results saved to {output}[/green]")
        
        return result
        
    except Exception as e:
        logger.error(f"Estimation failed: {str(e)}")
        console.print(f"[red]Error: {str(e)}[/red]")
        raise typer.Exit(1)


@app.command()
def simulate(
    n_samples: int = typer.Option(1000, help="Number of samples"),
    n_features: int = typer.Option(10, help="Number of features"),
    treatment_effect: float = typer.Option(1.0, help="True treatment effect"),
    output: Optional[str] = typer.Option(None, help="Output path for simulated data"),
    run_estimation: bool = typer.Option(True, help="Run estimation on simulated data")
):
    """
    ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã®ç”Ÿæˆã¨æ¨å®š
    
    Example:
        python -m src.core.engine simulate --n-samples 5000 --treatment-effect 2.0
    """
    console.print("[bold]Generating simulation data...[/bold]")
    
    # ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
    np.random.seed(42)
    X = np.random.randn(n_samples, n_features)
    
    # å‚¾å‘ã‚¹ã‚³ã‚¢ï¼ˆéç·šå½¢ï¼‰
    logit_ps = X[:, 0] + 0.5 * X[:, 1]**2 - X[:, 2]
    ps = 1 / (1 + np.exp(-logit_ps))
    T = np.random.binomial(1, ps)
    
    # ã‚¢ã‚¦ãƒˆã‚«ãƒ ï¼ˆå‡¦ç½®åŠ¹æœã‚ã‚Šï¼‰
    Y0 = X[:, 0] + X[:, 1] + np.random.randn(n_samples) * 0.5
    Y1 = Y0 + treatment_effect + 0.2 * X[:, 2]  # ãƒ˜ãƒ†ãƒ­åŠ¹æœ
    Y = T * Y1 + (1 - T) * Y0
    
    console.print(f"True ATE: {treatment_effect}")
    console.print(f"Treatment rate: {np.mean(T):.2%}")
    
    # ãƒ‡ãƒ¼ã‚¿ä¿å­˜
    if output:
        df = pd.DataFrame(X, columns=[f'X{i}' for i in range(n_features)])
        df['treatment'] = T
        df['outcome'] = Y
        df.to_csv(output, index=False)
        console.print(f"[green]Simulated data saved to {output}[/green]")
    
    # æ¨å®šå®Ÿè¡Œ
    if run_estimation:
        console.print("\n[bold]Running estimation on simulated data...[/bold]")
        engine = CQOEngine()
        result = engine.run(X, T, Y)
        
        # ãƒã‚¤ã‚¢ã‚¹è¨ˆç®—
        bias = result['ate'] - treatment_effect
        console.print(f"\n[bold]Bias: {bias:.4f}[/bold]")
        
        # è¢«è¦†ç¢ºèª
        covered = result['ci_lower'] <= treatment_effect <= result['ci_upper']
        console.print(f"True effect covered: {'âœ… Yes' if covered else 'âŒ No'}")


@app.command()
def validate(
    config: str = typer.Option(..., help="Config YAML path"),
    dry_run: bool = typer.Option(False, help="Validate config without execution")
):
    """
    è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®æ¤œè¨¼
    
    Example:
        python -m src.core.engine validate --config configs/base.yaml
    """
    try:
        with open(config, 'r') as f:
            config_data = yaml.safe_load(f)
        
        # å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒã‚§ãƒƒã‚¯
        required = ['module_a', 'gate', 'logging']
        missing = [field for field in required if field not in config_data]
        
        if missing:
            console.print(f"[red]Missing required fields: {missing}[/red]")
            raise typer.Exit(1)
        
        console.print("[green]âœ… Configuration valid[/green]")
        
        if not dry_run:
            # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
            console.print("\n[bold]Running test with config...[/bold]")
            X = np.random.randn(100, 5)
            T = np.random.binomial(1, 0.5, 100)
            Y = np.random.randn(100)
            
            engine = CQOEngine(config)
            result = engine.run(X, T, Y, verbose=False)
            console.print("[green]âœ… Test execution successful[/green]")
            
    except Exception as e:
        console.print(f"[red]Validation failed: {str(e)}[/red]")
        raise typer.Exit(1)


if __name__ == "__main__":
    # ãƒ­ã‚°è¨­å®š
    logger.add(
        "logs/cqo_{time}.log",
        rotation="100 MB",
        retention="30 days",
        level="DEBUG"
    )
    
    app()



